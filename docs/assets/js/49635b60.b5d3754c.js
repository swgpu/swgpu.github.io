"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5092],{7055:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>a,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var r=s(4848),i=s(8453);const t={},l="CurveInterpolator",o={id:"Module Core/CurveInterpolator",title:"CurveInterpolator",description:"Cubic curve interpolator",source:"@site/docs/Module Core/CurveInterpolator.md",sourceDirName:"Module Core",slug:"/Module Core/CurveInterpolator",permalink:"/docs/Module Core/CurveInterpolator",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Module Core/CurveInterpolator.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Curve",permalink:"/docs/Module Core/Curve"},next:{title:"EventManager",permalink:"/docs/Module Core/EventManager"}},c={},d=[{value:"Constructors",id:"constructors",level:2},{value:"Methods",id:"methods",level:2}];function h(n){const e={a:"a",br:"br",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"curveinterpolator",children:"CurveInterpolator"})}),"\n",(0,r.jsx)(e.p,{children:"Cubic curve interpolator"}),"\n",(0,r.jsx)(e.h2,{id:"constructors",children:"Constructors"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"new CurveInterpolator"}),"(points: Vector[], options: CurveInterpolatorOptions): default",(0,r.jsx)(e.br,{}),"\nCreate a new interpolator instance\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"points"}),": control points"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"options"}),": curve interpolator options"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"createLookupTable"}),"(func, samples: number, options): Map",(0,r.jsx)(e.br,{}),"\nCreate and cache a lookup table of n=samples points, indexed by position (u)"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"func"}),": function generating lookup table value"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"samples"}),": number of samples (segments)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"options"}),": object of { from, to, cacheKey } - if cacheKey is included, the map will be stored in the internal cache"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"forEach"}),"(func, samples, from: number, to: number): void",(0,r.jsx)(e.br,{}),"\nConvenience function for iterating over multiple values for a set of samples along the curve."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"The forEach function takes a user defined callback function, which will be called for each position"}),"\n",(0,r.jsx)(e.p,{children:"along the curve with its position (u), time (t), sample index (i) and the previous mapped value (prev)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"func"}),": callback function"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"samples"}),": number of (evenly spaced) samples OR an array of user specified positions (u)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"from"}),": from position"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"to"}),": to position"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getBoundingBox"}),"(from: number, to: number): BBox",(0,r.jsx)(e.br,{}),"\nGet a bounding box for the curve or the segment given by the"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"from and to parameters"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"from"}),": position from"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"to"}),": position to"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getCurvatureAt"}),"(position: number)",(0,r.jsx)(e.br,{}),"\nFinds the curvature and radius at the specified position (0..1) on the curve. The unsigned curvature"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"is returned along with radius, tangent vector and, for 2D and 3D curves, a direction vector is included"}),"\n",(0,r.jsx)(e.p,{children:"(which points toward the center of the curvature)."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0 - 1)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getCurvatureAtTime"}),"(t: number)",(0,r.jsx)(e.br,{}),"\nFinds the curvature and radius at the specified time (0..1) on the curve. The unsigned curvature"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"is returned along with radius, tangent vector and, for 2D and 3D curves, a direction vector is included"}),"\n",(0,r.jsx)(e.p,{children:"(which points toward the center of the curvature)."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"t"}),": time (t) along curve (0 - 1)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getDerivativeAt"}),"(position: number, target: T): T",(0,r.jsx)(e.br,{}),"\nGet the derivative at the given position."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0 - 1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getFrenetFrames"}),"(segments: number, from: number, to: number)",(0,r.jsx)(e.br,{}),"\nCalculate the Frenet-Serret frames for a 3d curve, using the concept of parallel transport."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["The implementation used here is basically a copy of the function used in THREE.js (",(0,r.jsx)(e.a,{href:"https://github.com/mrdoob/three.js",children:"https://github.com/mrdoob/three.js"}),"),"]}),"\n",(0,r.jsx)(e.p,{children:'which in turn is based on the the paper "Parallel Transport Approach to Curve Framing" by Hanson and Ma'}),"\n",(0,r.jsxs)(e.p,{children:["(",(0,r.jsx)(e.a,{href:"https://legacy.cs.indiana.edu/ftp/techreports/TR425.pdf",children:"https://legacy.cs.indiana.edu/ftp/techreports/TR425.pdf"}),")"]}),"\n",(0,r.jsx)(e.p,{children:"In the case of 2d, the normals are rotated 90 degrees counter-clockwise from the tangents and the binormals are omitted."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"segments"}),": number of samples (segments) along the curve (will return segments + 1 frames)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"from"}),": position from"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"to"}),": position to"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getIntersects"}),"(v: number, axis: number, max: number, margin: number)",(0,r.jsx)(e.br,{}),"\nFind points on the curve intersecting a specific value along a given axis. The axis is given as"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"an index from 0 - n, i.e. 0 = x-axis, 1 = y-axis, 2 = z-axis etc."}),"\n",(0,r.jsx)(e.p,{children:"The max parameter is used to specify the maximum number of solutions you want returned, where max=0"}),"\n",(0,r.jsx)(e.p,{children:"returns all solutions and a negative number will return the max number of solutions starting from"}),"\n",(0,r.jsx)(e.p,{children:"the end of the curve and a positive number starting from the beginning of the curve. Note that If"}),"\n",(0,r.jsx)(e.p,{children:"max = 1 or -1, this function returns the point (unwrapped) or null if no intersects exist. In any"}),"\n",(0,r.jsx)(e.p,{children:"other case an array will be returned, regardless of there's multiple, a single or no solutions."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"v"}),": lookup value"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"axis"}),": index of axis [0=x, 1=y, 2=z ...]"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"max"}),": max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"margin"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getIntersectsAsPositions"}),"(v: number, axis: number, max: number, margin: number)",(0,r.jsx)(e.br,{}),"\nFind positions (0-1) on the curve intersected by the given value along a given axis"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"v"}),": lookup value"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"axis"}),": index of axis [0=x, 1=y, 2=z ...]"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"max"}),": max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"margin"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getIntersectsAsTime"}),"(v: number, axis: number, max: number, margin: number)",(0,r.jsx)(e.br,{}),"\nFind intersects as time (0-1) on the curve intersected by the given value along a given axis"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"v"}),": lookup value"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"axis"}),": index of axis [0=x, 1=y, 2=z ...]"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"max"}),": max solutions (i.e. 0=all, 1=first along curve, -1=last along curve)"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"margin"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getLengthAt"}),"(position: number, clampInput: boolean): number"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0..1)"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"clampInput"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getNearestPosition"}),"(point: Vector, threshold: number, samples: number)",(0,r.jsx)(e.br,{}),"\nGet the nearest position on the curve from a point. This is an approximation and its"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"accuracy is determined by the threshold value (smaller number requires more passes but is more precise)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"point"}),": Vector"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"threshold"}),": Precision"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"samples"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getNormalAt"}),"(position: number, target: T): T",(0,r.jsx)(e.br,{}),"\nGet the normal for 2D or 3D curve at the given position. In 3D the normal"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"points towards the center of the curvature."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0 - 1)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getNormalAtTime"}),"(t: number, target: T): T",(0,r.jsx)(e.br,{}),"\nGet the normal for 2D or 3D curve at the given time (t). In 3D the normal"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"points towards the center of the curvature."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"t"}),": time at curve (0 - 1)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getPointAt"}),"(position: number, target: T): T",(0,r.jsx)(e.br,{}),"\nInterpolate a point at the given position."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0..1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getPointAtTime"}),"(t: number, target: VectorType): Vector",(0,r.jsx)(e.br,{}),"\nGet the point along the curve corresponding to the value of t (time along curve)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This function is only useful when you need to address the curve by time, where time"}),"\n",(0,r.jsx)(e.p,{children:"will vary depending on segment length and curvature. To address the curve normalized"}),"\n",(0,r.jsx)(e.p,{children:"for length (constant speed and uniform spacing), use the getPointAt function instead."}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"t"}),": time along full curve (encodes segment index and segment t)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target vector"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getPoints"}),"(segments: number, returnType)",(0,r.jsx)(e.br,{}),"\nGet uniformly sampled points along the curve. Returns samples + 1 points."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"segments"}),": number of samples (segments)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"returnType"}),": optional return type"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getPositionAtKnot"}),"(index: number): number",(0,r.jsx)(e.br,{}),"\nReturns the position (u) of the knot at the specified index"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"index"}),": index of knot (control/input point)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getPositionFromLength"}),"(length: number, clampInput: boolean): number",(0,r.jsx)(e.br,{}),"\nReturns the normalized position u for the specified length"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"length"})}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"clampInput"}),": whether the input value should be clamped to a valid range or not"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getPositionFromTime"}),"(t: number, clampInput: boolean): number",(0,r.jsx)(e.br,{}),"\nReturns the normalized position u for a normalized time value t"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"t"}),": time on curve (0..1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"clampInput"}),": whether the input value should be clamped to a valid range or not"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getSecondDerivativeAt"}),"(position: number, target: T): T",(0,r.jsx)(e.br,{}),"\nGet the second derivative at the given position."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0 - 1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getTangentAt"}),"(position: number, target: T): T",(0,r.jsx)(e.br,{}),"\nGet the tangent at the given position."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0 - 1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getTangentAtTime"}),"(t: number, target: T): T",(0,r.jsx)(e.br,{}),"\nGet the tangent at the given time."]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"t"}),": time at curve (0 - 1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"target"}),": optional target"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getTimeAtKnot"}),"(index: number): number",(0,r.jsx)(e.br,{}),"\nReturns the time (t) of the knot at the specified index"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"index"}),": index of knot (control/input point)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"getTimeFromPosition"}),"(position: number, clampInput: boolean): number",(0,r.jsx)(e.br,{}),"\nReturns the time on curve at a position, given as a value between 0 and 1"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"position"}),": position on curve (0..1)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"clampInput"}),": whether the input value should be clamped to a valid range or not"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"map"}),"(func, samples, from: number, to: number)",(0,r.jsx)(e.br,{}),"\nConvenience function for returning multiple values for a set of samples along the curve."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"The map function takes a user defined mapping function, which will be called for each position"}),"\n",(0,r.jsx)(e.p,{children:"along the curve with its position (u), time (t), sample index (i) and the previous mapped value (prev)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"func"}),": mapping function"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"samples"}),": number of (evenly spaced) samples OR an array of user specified positions (u)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"from"}),": from position"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"to"}),": to position"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"reduce"}),"(func, initialValue: T, samples, from: number, to: number): T",(0,r.jsx)(e.br,{}),"\nConvenience function for reducing multiple values for a set of samples along the curve."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This function takes a user defined reduce function, which will be called for each position"}),"\n",(0,r.jsx)(e.p,{children:"along the curve with its position (u), time (t), sample index (i) and the previous mapped value (prev)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"func"}),": reduce function"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"initialValue"}),": initial accumulator value"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"samples"}),": number of (evenly spaced) samples OR an array of user specified positions (u)"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"from"}),": from position"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"to"}),": to position"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"reset"}),"(): void",(0,r.jsx)(e.br,{}),"\nReset any pre-calculated/cached data"]}),"\n"]}),"\n"]})]})}function a(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>l,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function l(n){const e=r.useContext(t);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:l(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);